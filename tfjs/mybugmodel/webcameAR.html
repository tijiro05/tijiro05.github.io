<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <title>動植物識別AR</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.0.0/dist/tf.min.js"></script>
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <script src="https://unpkg.com/aframe-troika-text/dist/aframe-troika-text.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/ngokevin/aframe-look-at-component@master/dist/aframe-look-at-component.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        #webcam {
            position: absolute; top: 0; left: 0;
            width: 100vw; height: 100vh;
            object-fit: cover; z-index: 0;
        }
        #drawingCanvas {
            position: absolute; top: 0; left: 0;
            width: 100vw; height: 100vh;
            z-index: 5;
            pointer-events: none; /* ← 初期は無効化 */
        }
        #controlPanel {
            position: absolute;
            bottom: 10px; left: 50%;
            transform: translateX(-50%);
            background: rgba(255,255,255,0.9);
            padding: 10px; border-radius: 8px;
            z-index: 10;
            font-family: sans-serif;
            width: 90%;
            max-width: 500px;
            text-align: center;
            display: none; /* 初期状態では非表示 */
            justify-content: space-around;
            gap: 10px;
        }
        #predictButton, #clearButton {
            padding: 10px 20px;
            font-size: 18px;
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: background-color 0.3s ease;
        }
        #predictButton { background-color: #4caf50; }
        #predictButton:hover { background-color: #45a049; }
        #clearButton { background-color: #f44336; }
        #clearButton:hover { background-color: #d32f2f; }
        #predictButton:disabled { background-color: #ccc; cursor: not-allowed; }
        a-scene {
            position: absolute;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            z-index: 1;
        }
    </style>
</head>
<body>
    <video id="webcam" autoplay playsinline muted></video>
    <canvas id="drawingCanvas"></canvas>
    
    <div id="controlPanel">
        <button id="predictButton" disabled>分類する</button>
        <button id="clearButton">消去</button>
    </div>

    <a-scene embedded vr-mode-ui="enabled: false" ar-mode="false">
        <a-box id="cloverObj" position="0 0 -1" visible="false" scale="0.5 0.5 0.5"></a-box>
        <a-entity id="cameraRig" position="0 0 0">
            <a-entity camera look-controls position="0 1.6 0"></a-entity>
        </a-entity>
        <a-assets>
            <a-asset-item id="notojpFont" src="fonts/MPLUSRounded1c-Black.ttf"></a-asset-item>
        </a-assets>
        <a-entity id="cloverText" visible="false" position="0 0 -0.5" scale="0.5 0.5 0.5"  look-at="[camera]">
            <!-- 枠（木のフレーム風） -->
              <a-plane
                color="#5A3E2B"
                width="2.7"
                height="1.4"
                position="0 0 -0.01"
                material="shader: flat"
              ></a-plane>
            
              <!-- 黒板背景 -->
              <a-plane
                color="#2E4E3F"
                width="2.5"
                height="1.2"
                position="0 0 0"
                material="shader: flat"
              ></a-plane>

            <a-troika-text
                id="bubbleText"
                font="#notojpFont"
                value="ここに結果が表示されます"
                font-size="0.12"
                color="#FFFFFF"
                textAlign="center"
                position="0 0 0.01"
            ></a-troika-text>
        </a-entity>
    </a-scene>

    <script>
        const modelPath = 'model/model.json';
        const classLabels = ['蚊', 'バッタ', 'てんとう虫', 'アブラムシ', 'カメムシ', 'アリ', 'ハチ', 'チョウ', 'トンボ', 'セミ', 'シロツメクサ'];
        let model;
        const video = document.getElementById('webcam');
        const drawingCanvas = document.getElementById('drawingCanvas');
        const ctx = drawingCanvas.getContext('2d');
        const predictButton = document.getElementById('predictButton');
        const clearButton = document.getElementById('clearButton');
        const controlPanel = document.getElementById('controlPanel');

        let isDrawing = false;
        let points = [];

        function resizeCanvas() {
            drawingCanvas.width = video.offsetWidth;
            drawingCanvas.height = video.offsetHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        video.addEventListener('loadedmetadata', resizeCanvas);

        tf.loadLayersModel(modelPath).then((loadedModel) => {
            model = loadedModel;
        });

        async function setupCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment' },
                    audio: false,
                });
                video.srcObject = stream;
                
                // カメラの映像が読み込まれたらボタンを表示
                video.addEventListener('loadedmetadata', async () => {
                    controlPanel.style.display = 'flex';

                    // iOS Safari の場合、センサー許可が必要
                    if (typeof DeviceOrientationEvent !== "undefined" &&
                        typeof DeviceOrientationEvent.requestPermission === "function") {
                        try {
                            const res = await DeviceOrientationEvent.requestPermission();
                            if (res === "granted") {
                                drawingCanvas.style.pointerEvents = "auto"; // 許可後に有効化
                            }
                        } catch (e) {
                            console.warn("センサー許可が拒否されました:", e);
                        }
                    } else {
                        // Android / PC などはセンサー許可不要
                        drawingCanvas.style.pointerEvents = "auto";
                    }
                });
            } catch (err) {
                console.error("カメラへのアクセスが拒否されました。", err);
                alert("カメラへのアクセスを許可してください。");
            }
        }
        setupCamera();

        ctx.strokeStyle = '#007bff';
        ctx.lineWidth = 5;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        drawingCanvas.addEventListener('touchstart', (e) => {
            if (e.touches.length !== 1) return;
            e.preventDefault();
            isDrawing = true;
            const touch = e.touches[0];
            const x = touch.clientX;
            const y = touch.clientY;
            points = [{x: x, y: y}];
            ctx.beginPath();
            ctx.moveTo(x, y);
        });

        drawingCanvas.addEventListener('touchmove', (e) => {
            if (!isDrawing || e.touches.length !== 1) return;
            e.preventDefault();
            const touch = e.touches[0];
            const x = touch.clientX;
            const y = touch.clientY;
            points.push({x: x, y: y});
            ctx.lineTo(x, y);
            ctx.stroke();
            predictButton.disabled = false;
        });

        drawingCanvas.addEventListener('touchend', () => {
            isDrawing = false;
            ctx.closePath();
        });

        clearButton.addEventListener('click', () => {
            ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            points = [];
            predictButton.disabled = true;
            const cloverText = document.getElementById('cloverText');
            const cloverObj = document.getElementById('cloverObj');
            if (cloverText) cloverText.setAttribute('visible', false);
            if (cloverObj) cloverObj.setAttribute('visible', false);
        });

        predictButton.addEventListener('click', () => {
            if (!model || points.length < 2) return;

            const minX = Math.min(...points.map(p => p.x));
            const minY = Math.min(...points.map(p => p.y));
            const maxX = Math.max(...points.map(p => p.x));
            const maxY = Math.max(...points.map(p => p.y));

            const width = maxX - minX;
            const height = maxY - minY;

            if (width <= 0 || height <= 0) return;

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(video, minX, minY, width, height, 0, 0, width, height);

            const resizedCanvas = document.createElement('canvas');
            resizedCanvas.width = 224;
            resizedCanvas.height = 224;
            const resizedCtx = resizedCanvas.getContext('2d');
            resizedCtx.drawImage(tempCanvas, 0, 0, 224, 224);

            const imageData = resizedCtx.getImageData(0, 0, 224, 224);
            const tensor = tf.browser.fromPixels(imageData).toFloat().div(tf.scalar(255)).expandDims();

            model.predict(tensor).array().then(predictions => {
                const scores = predictions ? predictions.flat() : [];
                const topResultIndex = scores.indexOf(Math.max(...scores));
                const topLabel = classLabels.length > 0 && topResultIndex >= 0 ? classLabels[topResultIndex] : '不明';

                const cloverText = document.getElementById('cloverText');
                const bubbleText = document.getElementById('bubbleText');
                const cloverObj = document.getElementById('cloverObj');

                if (!cloverText || !bubbleText || !cloverObj) {
                    console.error("AR要素が見つかりません。");
                    return;
                }

                if (topLabel === 'シロツメクサ') {
                    cloverText.setAttribute('visible', true);
                    bubbleText.setAttribute('value', "これはシロツメクサ\nクローバーともいうよ");

                    const camera = document.querySelector('a-entity[camera]');
                    if (camera) {
                        const cameraWorldPosition = new THREE.Vector3();
                        camera.object3D.getWorldPosition(cameraWorldPosition);
                        const targetPosition = new THREE.Vector3(0, 0, -1.5);
                        targetPosition.applyQuaternion(camera.object3D.quaternion);
                        targetPosition.add(cameraWorldPosition);
                        cloverObj.setAttribute('position', targetPosition);
                        cloverObj.setAttribute('visible', true);

                        const objPos = cloverObj.getAttribute('position');
                        cloverText.setAttribute('position', {
                            x: objPos.x + 0.3,
                            y: objPos.y + 0.5,
                            z: objPos.z + 0.1
                        });
                    }
                } else {
                    cloverText.setAttribute('visible', false);
                    cloverObj.setAttribute('visible', false);
                    bubbleText.setAttribute('value', topLabel);
                }

                ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                points = [];
                predictButton.disabled = true;
            });
        });
        
        AFRAME.registerComponent('tail-update', {
            tick: function () {
                const cloverText = document.getElementById('cloverText');
                const tailBlack = document.getElementById('tailBlack');
                const tailWhite = document.getElementById('tailWhite');
                const cloverObj = document.getElementById('cloverObj');

                if (!cloverText || !tailBlack || !tailWhite || !cloverObj || !cloverText.getAttribute('visible') || !cloverObj.getAttribute('visible')) return;
                
                const bubblePos = new THREE.Vector3();
                cloverText.object3D.getWorldPosition(bubblePos);

                const targetPos = new THREE.Vector3();
                cloverObj.object3D.getWorldPosition(targetPos);

                const dir = new THREE.Vector3().subVectors(targetPos, bubblePos);
                dir.y = 0;

                if (dir.length() < 0.001) {
                    tailBlack.setAttribute('rotation', '0 0 0');
                    tailWhite.setAttribute('rotation', '0 0 0');
                    tailBlack.setAttribute('position', '0 -0.575 0');
                    tailWhite.setAttribute('position', '0 -0.525 0');
                    return;
                }
                
                dir.normalize();
                const angle = Math.atan2(dir.x, dir.z) * (180 / Math.PI);

                tailBlack.setAttribute('rotation', `0 ${angle} 0`);
                tailWhite.setAttribute('rotation', `0 ${angle} 0`);

                tailBlack.setAttribute('position', '0 -0.575 0');
                tailWhite.setAttribute('position', '0 -0.525 0');
            }
        });
        
        document.addEventListener('DOMContentLoaded', () => {
            const cloverText = document.getElementById('cloverText');
            if (cloverText) {
                cloverText.setAttribute('tail-update', '');
            }
        });
    </script>
</body>
</html>
