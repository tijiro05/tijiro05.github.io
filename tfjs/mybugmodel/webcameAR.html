<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <title>動植物識別AR</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.0.0/dist/tf.min.js"></script>
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <script src="https://unpkg.com/aframe-troika-text/dist/aframe-troika-text.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        #webcam {
            position: absolute; top: 0; left: 0;
            width: 100vw; height: 100vh;
            object-fit: cover; z-index: 0;
        }
        #drawingCanvas {
            position: absolute; top: 0; left: 0;
            width: 100vw; height: 100vh;
            z-index: 5;
            pointer-events: auto; /* タッチイベントを有効化 */
        }
        #controlPanel {
            position: absolute;
            bottom: 10px; left: 50%;
            transform: translateX(-50%);
            background: rgba(255,255,255,0.9);
            padding: 10px; border-radius: 8px;
            z-index: 10;
            font-family: sans-serif;
            width: 90%;
            max-width: 500px;
            text-align: center;
            display: flex;
            justify-content: space-around;
            gap: 10px;
            pointer-events: auto;
        }
        #controlPanel * {
            pointer-events: auto;
        }
        #predictButton, #clearButton {
            padding: 10px 20px;
            font-size: 18px;
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: background-color 0.3s ease;
        }
        #predictButton { background-color: #4caf50; }
        #predictButton:hover { background-color: #45a049; }
        #clearButton { background-color: #f44336; }
        #clearButton:hover { background-color: #d32f2f; }
        #predictButton:disabled { background-color: #ccc; cursor: not-allowed; }
        a-scene {
            position: absolute;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            z-index: 1;
            pointer-events: none; /* A-Frameのタッチイベントを無効化 */
        }
    </style>
</head>
<body>
    <video id="webcam" autoplay playsinline muted></video>
    <canvas id="drawingCanvas"></canvas>

    <div id="controlPanel">
        <button id="predictButton" disabled>分類する</button>
        <button id="clearButton">消去</button>
    </div>

    <a-scene embedded vr-mode-ui="enabled: false">
        <a-box id="cloverObj" position="0 0 -1" visible="false"></a-box>
        <a-entity id="cameraRig" position="0 0 0">
            <a-entity camera look-controls position="0 1.6 0"></a-entity>
        </a-entity>
        <a-assets>
            <a-asset-item id="notojpFont" src="fonts/MPLUSRounded1c-Black.ttf"></a-asset-item>
        </a-assets>
        <a-entity id="cloverText" visible="false" position="0 0 -0.5" scale="0.5 0.5 0.5">
            <a-plane color="#3D5348" width="2.5" height="1.2" position="0 0 -0.005" material="shader: flat; opacity: 1"></a-plane>
            <a-plane color="#476255" width="2.4" height="1.1" position="0 0 0" material="shader: flat; opacity: 1"></a-plane>
            <a-troika-text id="bubbleText" font="#notojpFont" value="ここに結果が表示されます" font-size="0.12" color="#FFFFFF" textAlign="center" position="0 0 0.01"></a-troika-text>
        </a-entity>
    </a-scene>

    <script>
        const modelPath = 'model/model.json';
        const classLabels = ['蚊', 'バッタ', 'てんとう虫', 'アブラムシ', 'カメムシ', 'アリ', 'ハチ', 'チョウ', 'トンボ', 'セミ', 'シロツメクサ'];
        let model;
        const video = document.getElementById('webcam');
        const drawingCanvas = document.getElementById('drawingCanvas');
        const ctx = drawingCanvas.getContext('2d');
        const predictButton = document.getElementById('predictButton');
        const clearButton = document.getElementById('clearButton');

        let isDrawing = false;
        let points = [];

        function resizeCanvas() {
            drawingCanvas.width = video.offsetWidth;
            drawingCanvas.height = video.offsetHeight;
        }

        tf.loadLayersModel(modelPath).then((loadedModel) => {
            model = loadedModel;
        });

        async function setupCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment' },
                    audio: false,
                });
                video.srcObject = stream;
            } catch (err) {
                console.error("カメラへのアクセスに失敗しました: ", err);
            }
        }

        ctx.strokeStyle = '#007bff';
        ctx.lineWidth = 5;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        function initializeApp() {
            video.addEventListener('play', () => {
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
            });

            drawingCanvas.addEventListener('touchstart', (e) => {
                if (e.touches.length !== 1) return;
                isDrawing = true;
                const touch = e.touches[0];
                const x = touch.clientX;
                const y = touch.clientY;
                points = [{ x, y }];
                ctx.beginPath();
                ctx.moveTo(x, y);
            });

            drawingCanvas.addEventListener('touchmove', (e) => {
                if (!isDrawing || e.touches.length !== 1) return;
                e.preventDefault();
                const touch = e.touches[0];
                const x = touch.clientX;
                const y = touch.clientY;
                points.push({ x, y });
                ctx.lineTo(x, y);
                ctx.stroke();
                predictButton.disabled = false;
            });

        drawingCanvas.addEventListener('touchend', () => {
            isDrawing = false;
            ctx.closePath();
        });
    }

    clearButton.addEventListener('click', () => {
        ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
        points = [];
        predictButton.disabled = true;
    });

    predictButton.addEventListener('click', () => {
        if (!model || points.length < 2) return;

        const minX = Math.min(...points.map(p => p.x));
        const minY = Math.min(...points.map(p => p.y));
        const maxX = Math.max(...points.map(p => p.x));
        const maxY = Math.max(...points.map(p => p.y));
        const width = maxX - minX;
        const height = maxY - minY;
        if (width <= 0 || height <= 0) return;

        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = width;
        tempCanvas.height = height;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(video, minX, minY, width, height, 0, 0, width, height);

        const resizedCanvas = document.createElement('canvas');
        resizedCanvas.width = 224;
        resizedCanvas.height = 224;
        const resizedCtx = resizedCanvas.getContext('2d');
        resizedCtx.drawImage(tempCanvas, 0, 0, 224, 224);

        const imageData = resizedCtx.getImageData(0, 0, 224, 224);
        const tensor = tf.browser.fromPixels(imageData).toFloat().div(tf.scalar(255)).expandDims();

        model.predict(tensor).array().then(predictions => {
            const scores = predictions ? predictions.flat() : [];
            const topResultIndex = scores.indexOf(Math.max(...scores));
            const topLabel = classLabels.length > 0 && topResultIndex >= 0 ? classLabels[topResultIndex] : '不明';

            const cloverText = document.getElementById('cloverText');
            const bubbleText = document.getElementById('bubbleText');
            const cloverObj = document.getElementById('cloverObj');

            bubbleText.setAttribute('value', topLabel);

            if (topLabel === 'シロツメクサ') {
                cloverText.setAttribute('visible', true);
                bubbleText.setAttribute('font-size', '0.12');
                bubbleText.setAttribute('value', "これはシロツメクサ\nクローバーともいうよ");

                const camera = document.querySelector('a-entity[camera]');
                const cameraWorldPosition = new THREE.Vector3();
                camera.object3D.getWorldPosition(cameraWorldPosition);
                const targetPosition = new THREE.Vector3(0, 0, -1.5);
                targetPosition.applyQuaternion(camera.object3D.quaternion);
                targetPosition.add(cameraWorldPosition);
                cloverObj.setAttribute('position', targetPosition);
                cloverObj.setAttribute('visible', true);

                const objPos = cloverObj.getAttribute('position');
                cloverText.setAttribute('position', {
                    x: objPos.x + 0.3,
                    y: objPos.y + 0.5,
                    z: objPos.z + 0.1
                });
            } else {
                cloverText.setAttribute('visible', false);
                cloverObj.setAttribute('visible', false);
            }

            ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            points = [];
            predictButton.disabled = true;
        });
    });

    function requestDeviceMotionPermission() {
        if (typeof DeviceMotionEvent?.requestPermission === 'function') {
            DeviceMotionEvent.requestPermission()
                .then(permissionState => {
                    initializeApp();
                })
                .catch((err) => {
                    console.error('センサーパーミッションエラー:', err);
                    initializeApp(); // 拒否されても初期化
                });
        } else {
            console.log('このブラウザは requestPermission をサポートしていません。');
            initializeApp();
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        setupCamera();
        const initialTouchHandler = () => {
            requestDeviceMotionPermission();
            document.removeEventListener('touchstart', initialTouchHandler);
        };
        document.addEventListener('touchstart', initialTouchHandler);
    });
    </script>
</body>
</html>
